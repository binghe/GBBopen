<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- XML file produced from file: tutorial.tex
     using Hyperlatex v 2.9-in-waiting-rk (c) Otfried Cheong -->
<head>
<title>GBBopen 0.9.9 Tutorial -- Add Another KS</title>
</p>
<link rel="SHORTCUT ICON" href="favicon.ico"><link rel=stylesheet
        href="gbbopen.css" type="text/css" />
</head>
<body>
<table width="100%" cellpadding="0" cellspacing="2"><tr>
<td bgcolor="#99ccff"><a href="tutorial-application-startup.html"><img border="0" alt="Application Startup and Event Functions" src="previous.png"/></a></td><td bgcolor="#99ccff"><a href="tutorial_0.html"><img border="0" alt="Top" src="up.png"/></a></td><td bgcolor="#99ccff"><a href="tutorial-connections.html"><img border="0" alt="Making Connections" src="next.png"/></a></td><td align="center" bgcolor="#99ccff" width="100%"><b>Add Another KS</b></td><td bgcolor="#99ccff"><a target="_top" href="tutorial.html"><img border="0" alt="GoTo Top" src="top.png"/></a></td></tr></table>
<h1>Add Another KS</h1>
<p>The last exercise made it easy to initialize and run our application
repeatedly by simply starting the Agenda Shell.  We also specified the
dimensionality of our <code>known-world</code> space instance relative to the
dimensional specifications of the <code>location</code> unit class.  With these
niceties in place, its time to move beyond our initial <code>location</code> unit
instance.
</p>
<p><hr color="99CCCC">
This exercise shows you how to:
</p>
<p><ul class="tight"><li>Add an additional dimension to a unit class
<li>Define a KS that obtains its execution-context information from its
triggering unit instance
<li>Extend the random-walk application to do some walking
<li>Explore the resulting random walk
</ul>
</p>
<hr color="99CCCC">
<h2><a name="id1">Prerequisites</a></h2>
<p><ul class="tight"><li>The <code>tutorial-example.lisp</code> file as modified thus far:
</ul>
</p>
<pre>
(in-package :gbbopen-user)

(define-unit-class location ()
  (x y)
  (:dimensional-values
    (x :point x)
    (y :point y))
  (:initial-space-instances (known-world)))

(defmethod print-instance-slots ((location location) stream)
  (call-next-method)
  (when (and (slot-boundp location 'x)
             (slot-boundp location 'y))
    (format stream " (~s ~s)"
            (x-of location)
            (y-of location))))

;;; ======================================================================
;;;   Startup KS

(defun startup-ks-function (ksa)
  (declare (ignore ksa))
  ;; Create an initial location unit instance at (0,0):
  (make-instance 'location :x 0 :y 0))

(define-ks startup-ks
    :trigger-events ((start-control-shell-event))
    :execution-function 'startup-ks-function)

;;; ======================================================================
;;;   Initializations (run at Agenda Shell startup)

(defun initializations (event-name &amp;key &amp;allow-other-keys)
  (declare (ignore event-name))
  ;; Clean up any previous run:
  (delete-blackboard-repository)
  ;; Make a new known-world space instance:
  (make-space-instance 
   '(known-world)
   :dimensions (dimensions-of 'location)))

(add-event-function 'initializations 'start-control-shell-event
                    ;; Initializations should be done first!
                    :priority 100)
</pre>
<p><ul class="tight"><li>The <code>:agenda-shell-user</code> module is loaded
</ul>
</p>
<h2><a name="id2">Step 1: Add  another dimension</a></h2><p>
It's time we introduce the notion of time to our application.  Edit the
<code>location</code> unit-class definition in <code>tutorial-example.lisp</code>, adding
a new slot, <code>time</code>, to the <code>location</code> unit class definition and a
corresponding <code>time</code> dimensional value:
</p>
<pre><font color="#666666">(define-unit-class location ()
  (<font color="#000000">time</font> 
   x y)
  (:dimensional-values
    <font color="#000000">(time :point time)</font>
    (x :point x)
    (y :point y))
  (:initial-space-instances (known-world)))
</pre></font>
<p>Recall that we specified that the dimensions of the <code>known-world</code> space
instance that is created by our <code>initializations</code> function relative to
the dimensions of the <code>location</code> unit class:
</p>
<pre><font color="#666666">  (make-space-instance 
      '(known-world)
      :dimensions (dimensions-of 'location)))
</pre></font>
<p>Therefore, we don't need to modify our call to <code>make-space-instance</code> in
order to add <code>time</code> as a dimension of <code>known-world</code>.
</p>
<p>Next, modify <code>startup-ks-function</code> in <code>tutorial-example.lisp</code> so
that it creates the initial <code>location</code> unit instance at time 0:
</p>
<pre><font color="#666666">(defun startup-ks-function (ksa)
  (declare (ignore ksa))
  ;; Create an initial location unit instance at (0,0) <font color="#000000">at time 0</font>:
  (make-instance 'location <font color="#000000">:time 0</font> :x 0 :y 0))
</pre></font>
<h2><a name="id3">Step 2: A test of time</a></h2><p>
Let's check our work.  Compile and load the
<code>tutorial-example.lisp</code> file directly from the editor buffer (using
<code>C-c C-k</code> in SLIME; <code>C-c C-b</code> in ELI) and start the Agenda Shell
again:
</p>
<pre><font color="#666666">  gbbopen-user&gt; <font color="#000000">(start-control-shell)</font>
  ;; Control shell 1 started
  ;; No executable KSAs remain, exiting control shell
  ;; Control shell 1 exited: 3 cycles completed
  ;; Run time: 0 seconds
  ;; Elapsed time: 0 seconds
  :quiescence
  gbbopen-user&gt;
</pre></font>
<p><a name="id4">Check</a> that the initial <code>location</code> unit instance is at <code>time</code> zero:
</p>
<pre><font color="#666666">  gbbopen-user&gt; <font color="#000000">(describe-instance (find-instance-by-name 1 'location))</font>
  Location #&lt;location 1 (0 0)&gt;
    Instance name: 1
    Space instances: ((known-world))
    Dimensional values:
      time:  0
      x:  40
      y:  60
    Non-link slots:
      time:  0
      x:  40
      y : 60
    Link slots: None
  gbbopen-user&gt;
</pre></font>
<h2><a name="id5">Step 3: Define another KS</a></h2><p>
Define a KS called <code>random-walk-ks</code> that:
</p>
<p><ul class="tight"><li>Is triggered when a <code>location</code> unit instance is created
<li>Has a constant KSA rating of 100
<li>Has an execution function called <code>random-walk-ks-function</code>, which:
</p>
<p><ul class="tight"><li>Checks if we've already walked for 75 locations and prints a message if
we have. 
<li>Otherwise:
</p>
<p><ul class="tight"><li>Determines a random location for which the x and y values are within 10
of the x and y values of the triggering unit instance (that is, the
<code>location</code> instance whose creation triggered the <code>random-walk-ks</code>
KS)
<li>If both of the x and y values for the new random location are between
-50 and 50, creates a <code>location</code> unit instance at the random location;
otherwise, prints a message indicating that we've walked off the world
</ul>
</ul>
</ul>
</p>
<h3><a name="id6">Step 3a: Define a utility function</a></h3><p>
Begin implementing the <code>random-walk-ks</code> by adding the following
utility function to the end of your <code>tutorial-example.lisp</code> file:
</p>
<pre>
;;; ======================================================================
;;;   Random-walk KS

(defun add-linear-variance (value max-variance)
  ;;; Returns a new random value in the interval
  ;;; [(- value max-variance), (+ value max-variance)]
  (+ value (- (random (1+ (* max-variance 2))) max-variance)))
</pre>
<p>Then compile the definition (using <code>C-c C-c</code> in SLIME or <code>C-c
C-x</code> in ELI) and evaluate the following test in the REPL:
</p>
<a name="id7"></a><pre><font color="#666666">  gbbopen-user&gt; <font color="#000000">(dotimes (i 15) (printv (add-linear-variance 0 10)))</font>
  ;;  (add-linear-variance 0 10) =&gt; 8
  ;;  (add-linear-variance 0 10) =&gt; 9
  ;;  (add-linear-variance 0 10) =&gt; 4
  ;;  (add-linear-variance 0 10) =&gt; 3
  ;;  (add-linear-variance 0 10) =&gt; -4
  ;;  (add-linear-variance 0 10) =&gt; -10
  ;;  (add-linear-variance 0 10) =&gt; -1
  ;;  (add-linear-variance 0 10) =&gt; 0
  ;;  (add-linear-variance 0 10) =&gt; 4
  ;;  (add-linear-variance 0 10) =&gt; 5
  ;;  (add-linear-variance 0 10) =&gt; 8
  ;;  (add-linear-variance 0 10) =&gt; -5
  ;;  (add-linear-variance 0 10) =&gt; -3
  ;;  (add-linear-variance 0 10) =&gt; 7
  ;;  (add-linear-variance 0 10) =&gt; 6
  nil
  gbbopen-user&gt;
</pre></font>
<p>Because <code>add-linear-variance</code> is stochastic, your results will be
similar but not identical.  Note that we used GBBopen's <b>printv</b>
macro to display the result of each generated value.  <b>Printv</b> can
greatly assist debugging by printing forms and the results of evaluating
them.  <b>Printv</b> can be transparently wrapped around any form in a
complex function definition, as it evaluates and displays all the forms in
its body and returns the values resulting from evaluating the last form:
</p>
<pre><font color="#666666">  gbbopen-user&gt;  (printv "Some multiple values" (values 1 2) "Some more" (values 3 4 5))
  ;; Some multiple values
  ;;  (values 1 2) =&gt; 1; 2
  ;; Some more
  ;;  (values 3 4 5) =&gt; 3; 4; 5
  4
  5
  6
  gbbopen-user&gt;
</pre></font>
<h3><a name="id8">Step 3b: Define the <code>random-walk-ks</code> execution function</a></h3><p>
Next add the following KS-execution function to the end of your
<code>tutorial-example.lisp</code> file:
</p>
<pre>
(defun random-walk-ks-function (ksa)
  ;;; Move to the next (random) location in the world
  (let* ((trigger-instance (sole-trigger-instance-of ksa))
         ;; The new time is one greater than the stimulus instance's time:
         (time (1+ (time-of trigger-instance))))
    (cond
     ;; If the maximum time value (75) is reached, tell the user we've
     ;; walked too long:
     ((&gt;= time 75) (format t "~2&amp;Walked too long.~&#37;"))
     (t ;; The new location is +/- 10 of the stimulus instance's location:
      (let ((x (add-linear-variance (x-of trigger-instance) 10))
            (y (add-linear-variance (y-of trigger-instance) 10)))
        (cond
         ;; Check that the new location is within the known-world
         ;; boundaries.  If so, create the new location instance:
         ((and (&lt;= -50 x 50) (&lt;= -50 y 50))
          (make-instance 'location 
            :time time 
            :x x 
            :y y))
         ;; Otherwise, tell the user that we've walked too far away:
         (t (format t "~2&#38;Walked off the world: (~d, ~d).~&#37;" x y))))))))
</pre>
<p><a name="id9">Unlike</a> the KS-execution functions that we have defined previously,
<code>random-walk-ks-function</code> does not ignore its <code>ksa</code> argument.
Instead, it calls <b>sole-trigger-instance-of</b> with the <code>ksa</code>
unit-instance argument in order to obtain the <code>location</code> unit instance
whose creation triggered the KSA.  This pattern of obtaining the unit instance
that triggered a KSA and then using that triggering unit instance as the
context for the KS execution is typical of many KSs. 
</p>
<h3><a name="id10">Step 3c: Add the <code>random-walk-ks</code> definition</a></h3><p>
Finally, add this <code>define-ks</code> form to the end of your
<code>tutorial-example.lisp</code> file to complete the <code>random-walk-ks</code>
definition:
</p>
<a name="id11"></a><pre>
(define-ks random-walk-ks
   :trigger-events ((create-instance-event location))
   :rating 100
   :execution-function 'random-walk-ks-function)
</pre>
<h2><a name="id12">Step 4:  Run the application</a></h2><p>
Compile and load the <code>random-walk-ks</code> forms, and then start the Agenda Shell:
</p>
<pre><font color="#666666">  gbbopen-user&gt; <font color="#000000">(start-control-shell)</font>
  ;; Control shell 1 started

  Walked off the world: (23, 55).
  ;; No executable KSAs remain, exiting control shell
  ;; Control shell 1 exited: 64 cycles completed
  ;; Run time: 0.01 seconds
  ;; Elapsed time: 0 seconds
  :quiescence
  gbbopen-user&gt;
</pre></font>
<p><a name="id13">It</a> looks like something happened! (Again, because <code>add-linear-variance</code>
is stochastic, your results will be similar but not identical.)  Let's look at
the blackboard repository and see how many <code>location</code> unit instances were
created:
</p>
<pre><font color="#666666">  gbbopen-user&gt; <font color="#000000">:dsbb</font>

  Space Instance                Contents
  --------------                --------
  known-world                   61 instances (61 location)

  Unit Class                    Instances
  ----------                    ---------
  control-shell                         1 *
  ks                                    1 +
  ksa-queue                             2 +
  location                             61
  ordered-ksa-queue                     1 +
  standard-space-instance               1
                                ---------
                                       67 instances
  gbbopen-user&gt;
</pre></font>
<p>The 61 <code>location</code> instances makes sense.  Previously, it required 3
control-shell cycles to create the initial <code>location</code> unit instance (one
to execute the <code>initial-ks</code> KSA followed by two additional cycles of
quiescence before the Agenda Shell exits).  We now create one additional
<code>location</code> unit instance with every execution of <code>random-walk-ks</code>,
so we always create 3 fewer <code>location</code> instances than the total
number of control-shell cycles.
</p>
<h2><a name="id14">Step 5:  Where have we been?</a></h2><p>
It would be interesting to see where our random walk has taken us.  We could
use GBBopen's <b>map-instances-of-class</b> iterator to print each of the
<code>location</code> unit instances:
</p>
<pre><font color="#666666">  gbbopen-user&gt; <font color="#000000">(map-instances-of-class #'print 'location)</font>

  #&lt;location 58 (5 31)&gt; 
  #&lt;location 13 (-7 10)&gt; 
  #&lt;location 26 (-40 35)&gt; 
  #&lt;location 39 (-4 3)&gt; 
  #&lt;location 52 (2 23)&gt; 
  #&lt;location 7 (3 17)&gt; 
  #&lt;location 20 (2 27)&gt; 
  #&lt;location 33 (-25 6)&gt; 
  #&lt;location 46 (-2 32)&gt; 
       ...
  #&lt;location 31 (-22 18)&gt; 
  #&lt;location 44 (-7 14)&gt; 
  #&lt;location 57 (2 41)&gt; 
  #&lt;location 12 (-15 15)&gt; 
  #&lt;location 25 (-32 38)&gt; 
  #&lt;location 38 (-10 -4)&gt; 
  #&lt;location 51 (-2 16)&gt; 
  #&lt;location 6 (10 27)&gt; 
  #&lt;location 19 (-1 17)&gt; 
  #&lt;location 32 (-25 12)&gt; 
  #&lt;location 45 (-7 23)&gt; 
  nil
  gbbopen-user&gt;
</pre></font>
<p>Unfortunately, the order that unit instances are supplied to the <code>print</code>
function is not controllable.  Our walk would be much clearer if we printed
the <code>location</code>s in time order.
</p>
<p><a name="id15">We</a> might consider taking advantage of the instance names that GBBopen assigns
to unit instances.  We could do something like the following:
</p>
<pre><font color="#666666">  gbbopen-user&gt; <font color="#ff0000">(dotimes (i 76)
                  (let ((location (find-instance-by-name i 'location)))
                    (when location
                       (print location))))</font>

  #&lt;location 1 (0 0)&gt; 
  #&lt;location 2 (10 4)&gt; 
  #&lt;location 3 (19 10)&gt; 
  #&lt;location 4 (14 9)&gt; 
  #&lt;location 5 (14 18)&gt; 
  #&lt;location 6 (10 27)&gt; 
  #&lt;location 7 (3 17)&gt; 
  #&lt;location 8 (-6 20)&gt; 
  #&lt;location 9 (4 15)&gt; 
  #&lt;location 10 (-5 14)&gt; 
       ...
  #&lt;location 50 (5 26)&gt; 
  #&lt;location 51 (-2 16)&gt; 
  #&lt;location 52 (2 23)&gt; 
  #&lt;location 53 (9 33)&gt; 
  #&lt;location 54 (7 43)&gt; 
  #&lt;location 55 (-2 36)&gt; 
  #&lt;location 56 (0 46)&gt; 
  #&lt;location 57 (2 41)&gt; 
  #&lt;location 58 (5 31)&gt; 
  #&lt;location 59 (13 39)&gt; 
  #&lt;location 60 (17 41)&gt; 
  #&lt;location 61 (21 50)&gt; 
  nil
  gbbopen-user&gt;
</pre></font>
<p>This is a bad idea for several reasons.  First, we are looking up every
<code>location</code> unit instance by its instance name, which is less efficient
than operating on <code>location</code> instances directly.  While this isn't an
significant issue in expressions that we evaluate in the REPL to investigate
our application, we should seek to avoid such inefficiencies in application
code.  More importantly, however, the <code>location</code> instance name just
happens to mirror the sequencing that we really want to display&mdash;the
<code>time</code> value of the <code>location</code>s.  We should find a way to sequence
<code>location</code> printing that relies on the <code>time</code> values directly.
</p>
<p><a name="id16">GBBopen</a> provides a variant of <b>map-instances-of-class</b>, called
<b>map-sorted-instances-of-class</b>, that sorts the unit instances based on
a comparison predicate and an optional <code>:key</code> accessor function that
suits our needs:
</p>
<pre><font color="#666666">  gbbopen-user&gt; <font color="#000000">(map-sorted-instances-of-class #'print 'location #'&lt; 
                   :key #'time-of)</font>

  #&lt;location 1 (0 0)&gt; 
  #&lt;location 2 (10 4)&gt; 
  #&lt;location 3 (19 10)&gt; 
  #&lt;location 4 (14 9)&gt; 
  #&lt;location 5 (14 18)&gt; 
  #&lt;location 6 (10 27)&gt; 
  #&lt;location 7 (3 17)&gt; 
  #&lt;location 8 (-6 20)&gt; 
  #&lt;location 9 (4 15)&gt; 
  #&lt;location 10 (-5 14)&gt; 
       ...
  #&lt;location 50 (5 26)&gt; 
  #&lt;location 51 (-2 16)&gt; 
  #&lt;location 52 (2 23)&gt; 
  #&lt;location 53 (9 33)&gt; 
  #&lt;location 54 (7 43)&gt; 
  #&lt;location 55 (-2 36)&gt; 
  #&lt;location 56 (0 46)&gt; 
  #&lt;location 57 (2 41)&gt; 
  #&lt;location 58 (5 31)&gt; 
  #&lt;location 59 (13 39)&gt; 
  #&lt;location 60 (17 41)&gt; 
  #&lt;location 61 (21 50)&gt; 
  nil
  gbbopen-user&gt;
</pre></font>
<p><a name="id17">Using</a> <b>map-sorted-instances-of-class</b> involves a sorting operation, so
this approach still has some efficiency concerns for use in application code.
However, it suits our REPL-exploration needs just fine.  (There is a
<b>do-sorted-instances-of-class</b> macro, if an iterative style is
preferred over a mapper.)  We will explore a more efficient approach to
displaying the random walk in the next exercise.
</p>
<h2><a name="id18">Step 6:  Run the application a few more times</a></h2><p>
If we run the application a few more times, we eventually encounter a case
where we create the allotted 75 <code>location</code> unit instances without walking
off the <code>known-world</code>:
</p>
<pre><font color="#666666">  gbbopen-user&gt; <font color="#000000">(start-control-shell)</font>
  ;; Control shell 1 started

  Walked too long.
  ;; No executable KSAs remain, exiting control shell
  ;; Control shell 1 exited: 78 cycles completed
  ;; Run time: 0.04 seconds
  ;; Elapsed time: 0 seconds
  :quiescence
  gbbopen-user&gt;
</pre></font>
<p><a name="id19">Here</a> is one such random walk:
</p>
<pre><font color="#666666">  gbbopen-user&gt; <font color="#000000">(map-sorted-instances-of-class #'print 'location #'&lt; 
                   :key #'time-of)</font>

  #&lt;location 1 (0 0)&gt; 
  #&lt;location 2 (2 7)&gt; 
  #&lt;location 3 (-1 5)&gt; 
  #&lt;location 4 (-1 0)&gt; 
  #&lt;location 5 (3 -2)&gt; 
  #&lt;location 6 (13 -7)&gt; 
  #&lt;location 7 (8 -5)&gt; 
  #&lt;location 8 (1 2)&gt; 
  #&lt;location 9 (8 0)&gt; 
  #&lt;location 10 (5 8)&gt; 
       ...
  #&lt;location 70 (-13 -11)&gt; 
  #&lt;location 71 (-13 -6)&gt; 
  #&lt;location 72 (-9 -6)&gt; 
  #&lt;location 73 (1 -4)&gt; 
  #&lt;location 74 (-8 -11)&gt; 
  #&lt;location 75 (-13 -15)&gt; 
  nil
  gbbopen-user&gt;
</pre></font>
<hr /><address><a target="_top" class="address"
    href="http://GBBopen.org/"><p>The GBBopen Project</a></address><br />
<table width="100%" cellpadding="0" cellspacing="2"><tr>
<td bgcolor="#99ccff"><a href="tutorial-application-startup.html"><img border="0" alt="Application Startup and Event Functions" src="previous.png"/></a></td><td bgcolor="#99ccff"><a href="tutorial_0.html"><img border="0" alt="Top" src="up.png"/></a></td><td bgcolor="#99ccff"><a href="tutorial-connections.html"><img border="0" alt="Making Connections" src="next.png"/></a></td><td align="center" bgcolor="#99ccff" width="100%"><b>Add Another KS</b></td><td bgcolor="#99ccff"><a target="_top" href="tutorial.html"><img border="0" alt="GoTo Top" src="top.png"/></a></td></tr></table></body></html>
